<?php

  error_reporting(0);
  set_include_path(get_include_path() . PATH_SEPARATOR . dirname(__FILE__) . '/pear_ext');

  /*

    Anthologize ePub generator

    1. Create directory structure in temporary ePub directory
    2. Populate ePub directory with fixed files (mimetype and container.xml)
    3. Grab all images referenced in Anthologize exchange TEI file and put into temporary ePub dir
    4. Transform Anthologize exchange TEI format data into ePub NCX, OPF, and HTML files & save into temporary ePub dir
    5. Zip up temporary ePub dir and serve it out
    6. Delete all temp stuff

  */

$ops = array('includeStructuredSubjects' => false, //Include structured data about tags and categories
		'includeItemSubjects' => false, // Include basic data about tags and categories
		'includeCreatorData' => false, // Include basic data about creators
		'includeStructuredCreatorData' => false, //include structured data about creators
		'includeOriginalPostData' => true, //include data about the original post (true to use tags and categories)
		'checkImgSrcs' => true, //whether to check availability of image sources
		'linkToEmbeddedObjects' => false, //whether to replace embedded objects with a link to them
		'indexSubjects' => false,
		'indexCategories' => false,
		'indexTags' => false,
		'indexAuthors' => false,
		'indexImages' => false,
		);


$ops['outputParams'] = $_SESSION['outputParams'];



  if (!class_exists('XSLTProcessor', false))
    die ('ePub export requires XSL support');

  require_once('Archive.php');

  define('TEI',  'http://www.tei-c.org/ns/1.0'  );
  define('HTML', 'http://www.w3.org/1999/xhtml' );
  define('ANTH', 'http://www.anthologize.org/ns');

  $plugin_dir = WP_PLUGIN_DIR . DIRECTORY_SEPARATOR . 'anthologize';
  $epub_dir   = $plugin_dir . DIRECTORY_SEPARATOR . 'templates' . DIRECTORY_SEPARATOR . 'epub';


  include_once(ANTHOLOGIZE_TEIDOM_PATH);

  // Directory and filename constants

  $upload_dir_array       = wp_upload_dir();
  $temp_dir_name          = $upload_dir_array['basedir'] . DIRECTORY_SEPARATOR . 'epub-tmp'; // Temporary area for building ZIP
  $temp_epub_dir_name     = $temp_dir_name       . DIRECTORY_SEPARATOR . 'epub_under_construction'; // ePub dir structure temp area
  $temp_epub_meta_inf_dir = $temp_epub_dir_name  . DIRECTORY_SEPARATOR . 'META-INF';
  $temp_epub_oebps_dir    = $temp_epub_dir_name  . DIRECTORY_SEPARATOR . 'OEBPS';
  $temp_epub_images_dir   = $temp_epub_oebps_dir; // . DIRECTORY_SEPARATOR . 'images';

  $temp_zip_filename      = $temp_dir_name       . DIRECTORY_SEPARATOR . 'book.epub'; // Temporary ZIP file
  $zip_download_filename  = TeiDom::getFileName($_SESSION) . '.epub'; // The name of the filename when it downloads

  $mimetype_filename = $temp_epub_dir_name .  DIRECTORY_SEPARATOR . "mimetype";
  $container_filename = $temp_epub_dir_name .  DIRECTORY_SEPARATOR . "META-INF" .  DIRECTORY_SEPARATOR . "container.xml";

  $xsl_html_file = $epub_dir . DIRECTORY_SEPARATOR . 'tei2html.xsl';
  $xsl_ncx_file  = $epub_dir . DIRECTORY_SEPARATOR . 'tei2ncx.xsl';
  $xsl_opf_file  = $epub_dir . DIRECTORY_SEPARATOR . 'tei2opf.xsl';

  // Set internal & output text encoding to UTF-16

  // iconv_set_encoding("internal_encoding", "UTF-16");
  // iconv_set_encoding("output_encoding",   "UTF-16");

  // Create temp directory if doesn't exist

  if (! file_exists ( $temp_dir_name ))
  {
    mkdir($temp_dir_name, 0777, true);
  }

  // Create directories in temp directory

  mkdir($temp_epub_meta_inf_dir, 0777, true);
  mkdir($temp_epub_oebps_dir,    0777, true);

  if (! file_exists($temp_epub_images_dir))
  {
    mkdir($temp_epub_images_dir,   0777, true);
  }

  // TODO: store images to OEBPS/images subdirectory

  // Create & populate mimetype file

  $fp = fopen($mimetype_filename, "w") or die("Couldn't open temporary file for epub archive (mimetype)");
  fwrite($fp, "application/epub+zip");
  fclose($fp);

  // Create & populate container.xml file

  $fp = fopen($container_filename, "w") or die("Couldn't open temporary file for epub archive (container.xml)");

  $container_file_contents  = '<?xml version="1.0"?>';
  $container_file_contents .= '<container version="1.0" xmlns="urn:oasis:names:tc:opendocument:xmlns:container">';
  $container_file_contents .= '<rootfiles>';
  $container_file_contents .= '<rootfile full-path="OEBPS/book.opf" media-type="application/oebps-package+xml"/>';
  $container_file_contents .= '</rootfiles>';
  $container_file_contents .= '</container>';

  fwrite($fp, $container_file_contents);
  fclose($fp);

  // Load intermediate TEI file
  // generated by anthologize/includes/class-tei-dom.php

  $tei_data = new TeiDom($_SESSION, $ops);
  $teiDom = $tei_data->getTeiDom();

  // Get all images referenced in intermediate TEI file & copy over to image directory
  // DOM Query using xpath: http://www.exforsys.com/tutorials/php-oracle/querying-a-dom-document-with-xpath.html

  $xpath = new DOMXPath($teiDom);
  $xpath->registerNamespace('tei', TEI);
  $xpath->registerNamespace('html', HTML);
  $xpath->registerNamespace('anth', ANTH);

  $query = '//img/@src';
  $image_url_nodes = $xpath->query($query);

  foreach ($image_url_nodes as $image_url_node) // Iterate through images
  {
    // Get image url & open file

    $image_url = $image_url_node->nodeValue;
    $image_filename = preg_replace('/^.*\//', '', $image_url); // Erase all but filename from URL (no directories)

    // TODO: check mimetype of image and assign generated name to file rather than derive from URL as above

    $ch = curl_init($image_url);

    $fp = fopen($temp_epub_images_dir . DIRECTORY_SEPARATOR . $image_filename, "w");

    // Fetch image from url & put into file

    curl_setopt($ch, CURLOPT_FILE, $fp);
    curl_setopt($ch, CURLOPT_HEADER, 0);
    curl_exec($ch);
    curl_close($ch);

    fclose($fp);
  }

  // Load XSLT tylesheets

  $tei2html_xsl = new DOMDocument();
  $tei2html_xsl->load($xsl_html_file);

  $tei2ncx_xsl = new DOMDocument();
  $tei2ncx_xsl->load($xsl_ncx_file);

  $tei2opf_xsl = new DOMDocument();
  $tei2opf_xsl->load($xsl_opf_file);

  // Create XSLT processor

  $proc = new XSLTProcessor();

  // Import stylesheets & transform & save

  $html_filename = $temp_epub_oebps_dir . DIRECTORY_SEPARATOR . "main_content.html";
  $ncx_filename  = $temp_epub_oebps_dir . DIRECTORY_SEPARATOR . "toc.ncx";
  $opf_filename  = $temp_epub_oebps_dir . DIRECTORY_SEPARATOR . "book.opf";

  // Write XHTML file

  $proc->importStylesheet($tei2html_xsl);
  $fp = fopen($html_filename, "w") or die("Couldn't open temporary file for epub archive (main_content.html)");
  // die(preg_replace('/</u','&lt;', $teiDom->saveXML()));
  $html = $proc->transformToXML($teiDom);
  //die(preg_replace('/</u','&lt;', $html));
  $empty_namespace_pattern = '/\sxmlns=""\s/i';
  $html_no_empty_namespaces = preg_replace('/xmlns=""/u', '', $html);
  fwrite($fp, $html_no_empty_namespaces);
  fclose($fp);

  // Write NCX file

  $proc->importStylesheet($tei2ncx_xsl);
  $fp = fopen($ncx_filename, "w") or die("Couldn't open temporary file for epub archive (toc.ncx)");
  fwrite($fp, $proc->transformToXML($teiDom));
  fclose($fp);

  // Write OPF file

  $proc->importStylesheet($tei2opf_xsl);
  $fp = fopen($opf_filename, "w") or die("Couldn't open temporary file for epub archive (book.opf)");
  fwrite($fp, $proc->transformToXML($teiDom));
  fclose($fp);

  // zip up contents of temp directory into a ZIP file

  zip_it($temp_epub_dir_name, $temp_zip_filename) or die("Couldn't create ZIP archive file: '" . $temp_zip_filename . "'");

  // Serve up zip file

  header("Content-type: application/epub+zip");
  header("Content-Disposition: attachment; filename=" . $zip_download_filename);
  header("Pragma: no-cache");
  header("Expires: 0");
  readfile($temp_zip_filename);

  // Delete all contents in temp dir
  // Code derived from http://www.php.net/manual/en/class.recursiveiteratoriterator.php

  deleteDirectoryWithContents($temp_epub_dir_name);
  unlink($temp_zip_filename);

  die();  // END

  // Function to take a source directory and zip it up into a destination archive
  // Code derived from http://stackoverflow.com/questions/1334613/how-to-recursively-zip-a-directory-in-php

  function zip_it($source, $destination)
  {
    $source = realpath($source);

    if (is_readable($source) === true)
    {
      // ZIP extension code

      if (extension_loaded('zip') === true)
      {
        $zip = new ZipArchive();

        if ($zip->open($destination, ZIPARCHIVE::CREATE) === true)
        {
          $files = new RecursiveIteratorIterator(new RecursiveDirectoryIterator($source), RecursiveIteratorIterator::SELF_FIRST);

          // Iterate through files & directories and add to archive object

          foreach ($files as $file)
          {
            if (is_dir($file) === true) // Create directories as they are found
            {
              $zip->addEmptyDir(str_replace($source . '/', '', $file . '/'));
            }
            else if (is_file($file) === true) // Add files as they are found
            {
              $zip->addFromString(str_replace($source . '/', '', $file), file_get_contents($file));
            }
          }
        }
        else
        {
          echo "Couldn't create zip file<br />";
        }
        return $zip->close();
      }

      // ZLib extension code

      elseif (extension_loaded('zlib') === true)
      {
        $original_dir = getcwd(); // Remember CWD for later reset
        chdir($source);           // Set CWD to temp area

        // ZIP up files

        File_Archive::extract(
          File_Archive::read('.'),
          File_Archive::toArchive(
              $destination,
              File_Archive::toFiles(),
              'zip'
          )
        );

        chdir($original_dir); // Reset CWD

        // TODO: add filesize check?
        if (is_readable($destination))
        {
          return true;
        }
      }

      // No ZIP compression available

      else
      {
        die("ePub requires a ZIP compression library");
      }
    }
    else
    {
      echo "Source content does not exist or is not readable<br />";
    }

    return false;
  }

  // Delete a directory and its contents
  // Derived from code at http://nashruddin.com/Remove_Directories_Recursively_with_PHP

  function deleteDirectoryWithContents ($dir)
  {
    $files = scandir($dir);
    array_shift($files);    // remove '.' from array
    array_shift($files);    // remove '..' from array

    foreach ($files as $file)
    {
      $file = $dir . DIRECTORY_SEPARATOR . $file;

      if (is_dir($file))
      {
        deleteDirectoryWithContents($file);
      }
      else
      {
        unlink($file);
      }
    }
    rmdir($dir);
  }

?>
